# 仅使用 `CSS` 创建多彩的、智能的阴影

## 背景

> 有没有想过如何创建从前景元素中继承某些颜色的阴影效果？阅读本文并找出如何实现方法吧！

前几天我经过家得宝（Home Depot，美国家得宝公司，全球领先的家居建材用品零售商），他们正在大规模展销正在出售的智能灯 `💡`，其中一种是一系列灯泡位于电视机后面，它们会投射出与电视机前景屏幕上显示的颜色相近的灯光，类似于以下图片所示。

![14.0](http://127.0.0.1:8080/%23css/images/14.0.png)

注意电视后面发生了什么。电视机屏幕前景中显示的颜色被灯投影成彩色阴影背景。随着屏幕上颜色的变化，背景投影颜色也发生变化。真的很酷，对吧？

看到这一点后，自然而然地我首先想到的是，能否使用 `web开发技术` 创建一个五颜六色的，并且足够聪明可以模拟前景颜色的阴影呢？事实证明，在只使用 `CSS` 的情况下，完全可以实现这种效果。在本文中，我们将研究如何实现。

开干！

## 令其成真

在接下来的段落中你将会发现，刚开始时，乍一看仅使用 `CSS` 来创建智能的彩色阴影似乎是一项艰巨的任务，当我们循序渐进，把困难部分拆分成更小的部分时，你就会发现一切都会变得容易理解消化。在接下来的章节中，我们将创建一个如下所示的示例：

![14.1](http://127.0.0.1:8080/%23css/images/14.1.gif)

你看到的是一张寿司 `🍣` 的图片，后面有与前景颜色相对应的阴影。为了强调我们所做的是动态的，给阴影增加了一个脉动动画效果。通过这个有效的示例，让我们深入探讨如何仅在使用 `HTML` 和 `CSS` 的情况下让一切变得生动起来。

## 展示图片

用于展示寿司 `🍣` 的 `HTML` 如下所示并没有什么特别：

```html
<div class="parent">
  <div class="colorfulShadow sushi"></div>
</div>
```

我们有一个父级 `div` 元素 `.parent`，它包含一个子级元素 `.suchi` 用于展示 `🍣`。我们通过使用一张背景图片的形式来实例化 `🍣`，`.sushi` 元素的具体样式规则如下：

```css
.sushi {
  margin: 100px;
  width: 150px;
  height: 150px;
  background-image: url("https://www.kirupa.com/icon/1f363.svg");
  background-repeat: no-repeat;
  background-size: contain;
}
```

In this style rule, we specify the size of our div to be 150 by 150 pixels, and we set the background-image and related properties on it. If take stock of where we are right now, the HTML and CSS we have seen will give us something that looks as follows:

![14.2](http://127.0.0.1:8080/%23css/images/14.2.png)

## 创建阴影

Now that we have our image appearing, all that remains is the even more fun part of us defining the shadow. The way we are going to define the shadow is by specifying a child pseudo-element (using after) that will do three things:
Be positioned directly behind our image
Inherit the same background image as the parent element
Rely on filters to apply the colorful drop-shadow effect
These three things are done by the following two style rules:

```css
.colorfulShadow {
  position: relative;
}
.colorfulShadow::after {
  content: "";
  width: 100%;
  height: 100%;
  position: absolute;
  background: inherit;
  background-position: center center;
  filter: drop-shadow(0px 0px 10px rgba(0, 0, 0, 0.50)) blur(20px);
  z-index: -1;
}
```

Take a few moments to walk through what is going on here. Pay close attention to each property and its value. Some notable callouts here are the background and filter properties. The background property has a value of inherit, which means its value will be the background of the parent:

```css
.colorfulShadow::after {
  content: "";
  width: 100%;
  height: 100%;
  position: absolute;
  background: inherit;
  background-position: center center;
  filter: drop-shadow(0px 0px 10px rgba(0, 0, 0, 0.50)) blur(20px);
  z-index: -1;
}
```

The filter property has two filters defined: drop-shadow and blur:

```css
.colorfulShadow::after {
  content: "";
  width: 100%;
  height: 100%;
  position: absolute;
  background: inherit;
  background-position: center center;
  filter: drop-shadow(0px 0px 10px rgba(0, 0, 0, 0.50)) blur(20px);
  z-index: -1;
}
```

Our **drop-shadow** filter is set to display a black shadow with 50% opacity, and our **blur** filter will blur our pseudoelement by 20px. The combination of these two filters is what ends up creating the colorful shadow that will now appear behind our sushi image when these two style rules get applied:

![14.3](http://127.0.0.1:8080/%23css/images/14.3.png)

At this point, we are pretty much adone. For completeness, if you want the animation where the colorful drop shadow scales in and out, the following additions to our existing CSS will get you there:

```css
.colorfulShadow {
  position: relative;
}
.colorfulShadow::after {
  content: "";
  width: 100%;
  height: 100%;
  position: absolute;
  background: inherit;
  background-position: center center;
  filter: drop-shadow(0px 0px 10px rgba(0, 0, 0, 0.50)) blur(20px);
  z-index: -1;
  /* animation time! */
  animation: oscillate 1s cubic-bezier(.17, .67, .45, 1.32) infinite alternate;
}

@keyframes oscillate {
  from {
    transform: scale(1, 1);
  }
  to {
    transform: scale(1.3, 1.3);
  }
}
```

If you want some interactivity without having a constantly looping animation, you can also use a CSS transition to change how the shadow behaves on some action like hover. The difficult part is to just treat the pseudo element just like you would any other element that you would explicitly define in HTML or dynamically create using JavaScript. The only difference is that this element is created fully using just CSS!

## 结论

Pseudo elements allow us to use CSS to accomplish some of the element creation tasks that historically have been within HTML's and JavaScript's domain. For our colorful and smart drop shadow, we relied on the parent element to have a background image set. This allowed us to easily define a child pseudoelement that both inherited the parent's background image details but also allowed us to set a bunch of properties on it for the blur and drop shadow effect. While all of this is good and we minimized a lot of copying & pasting, this approach isn't very flexible.

What if I want to apply a shadow like this to an element that isn't just empty with a background image? What if I have an HTML element like a button or combobox that I want to have this drop shadow effect applied to? One solution is to rely on JavaScript to duplicate the appropriate elements in the DOM, position them below the foreground elements, apply the filters, and call it a day. While this works, I always shudder a bit at duplicating DOM elements given how heavy weight the process is. Too bad JavaScript doesn't have the equivalent of renderTargetBitmap where any visual you provide is easily turned into a bitmap that you can then do whatever you want with! 🥶

Got a question or just want to chat? Comment below or drop by our forums (they are actually the same thing!) where a bunch of the friendliest people you'll ever run into will be happy to help you out!

> 本文是翻译，原文地址 <https://www.kirupa.com/html5/creating_colorful_smart_shadows.htm>
