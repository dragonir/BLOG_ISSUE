# 位运算

## 按位操作符

`JavaScript` 中使用 `IEEE-754` 64位存储。位操作符不能直接操作 `64位` 的值，而是将它转换为二进制补码形式的 `32位` 的整数，最后再将结果转为 `64位` 。`32位` 中 `31位` 表示整数的值，第 `32位` 为符号位（`0` 为正数，`1` 为负数）。每一位由二进制数存储，`31位` 中的每一位的索引表示 `2` 的次幂乘与每一位的 `0` 或者 `1`。没有使用到的位将使用 `0` 填充。

例如：31的32位二进制数表示为 `0000 0000 0000 0000 0000 0000 0001 1111` 。第32位 `0` 表示符号位，`11111` 为有效位。

| 1       | 1       | 1       | 1       | 1       |
| ------- | ------- | ------- | ------- | ------- |
| 2^4 *1 | 2^3* 1 | 2^2 *1 | 2^1* 1 | 2^0 * 1 |
| 16      | 8       | 4       | 2       | 1       |

## 负数

负数使用二进制存储，但是使用二进制补码表示

### 如何求一个数的二进制补码？

- 求出该数绝对值的二进制码
- 将获得的二进制码取反（`1` 变成 `0` ，`0` 变成 `1`）
- 二进制码加1

例如：如何求出-31的二进制补码。`-31` 的二进制补码的结果为 `1111 1111 1111 1111 1111 1111 1110 0001`。

`-31` 的绝对值为 `31`，求出 `31` 的二进制的码

`0000 0000 0000 0000 0000 0000 0001 1111`

将 `31` 的二进制码的 `0` 和 `1` 颠倒

`1111 1111 1111 1111 1111 1111 1110 0000`

将二进制码加 `1`

```ruby
1111 1111 1111 1111 1111 1111 1110 0000
                                     +1
---------------------------------------
1111 1111 1111 1111 1111 1111 1110 0001
```

## 无符号数

`ECMAScript` 所有整数都是有符号位的。在无符号数中，第 `32` 位不表示符号，因为无符号数只能是正数，`32` 位无符号数可以表示更大的数。

## 特殊值的处理

在 `NaN` 和 `Infinity` 在位运算符中会被当作 `0` 处理。非数值类型会先使用 `Number()` 处理，然后再应用位操作符。

## 按位非(NOT)

按位非 `~` 会将数值的32位二进制的每一位取反(0变为1，1变为0)。按位非的操作符的本质取操作数的负值，然后减一。

```javascript
~23       // -24
~100      // -101
～-10     // 9
～-101    // 100
```

例如：10进行按位非之后的结果，等于-11

```ruby
0000 0000 0000 0000 0000 0000 0000 1010
// ~ NOT
1111 1111 1111 1111 1111 1111 1111 0101
```

## 按位与(AND)

按位与 `&`, 本质上将两个操作数的32位二进制数的每一位对齐。然后按如下的规则取值，`1 & 1 等于 1`； `1 & 0 等于 0`；`0 & 1 等于0`；`0 & 0等于0`。

例如：10和5之间进行按位与操作的结果，等于0

```ruby
0000 0000 0000 0000 0000 0000 0000 1010
// & AND
0000 0000 0000 0000 0000 0000 0000 0101
// 等于
0000 0000 0000 0000 0000 0000 0000 0000
```

## 按位或(OR)

按位与 `|`, 本质上将两个操作数的32位二进制数的每一位对齐。然后按如下的规则取值，`1 | 1 等于 1` ； `1 | 0 等于 1` ；`0 | 1 等于1` ；`0 | 0等于0`。

例如：10和5之间进行按位或操作的结果，等于15

```ruby
0000 0000 0000 0000 0000 0000 0000 1010
// & OR
0000 0000 0000 0000 0000 0000 0000 0101
// 等于
0000 0000 0000 0000 0000 0000 0000 1111
```

## 按位异或(XOR)

按位异或 `^`, 本质上将两个操作数的 `32位` 二进制数的每一位对齐。然后按如下的规则取值，`1 ^ 1 等于 0` ； `1 ^ 0 等于 1` ；`0 ^ 1 等于1` ；`0 ^ 0等于0` 。

例如：10和5之间进行按位异或操作的结果15。

```ruby
0000 0000 0000 0000 0000 0000 0000 1010
// ^ XOR
0000 0000 0000 0000 0000 0000 0000 0101
// 等于
0000 0000 0000 0000 0000 0000 0000 1111
```

## 左移

左移(`<<`)将 `32位` 二进制向左移动指定的位数，空缺的位将会使用 `0` 填充。左移不会影响符号位

例如：将5左移2位，等于20

```ruby
0|000 0000 0000 0000 0000 0000 0000 0101
// <<2
0|000 0000 0000 0000 0000 0000 0001 0100
// 等于
(2^0 * 0) + (2^1 * 0) + (2^2 * 1) + (2^3 * 0) + (2^4 * 1) = 0 + 0 + 4 + 0 + 16 = 20
```

## 有符号位右移

右移(`>>`)将 `32` 位二进制向右移动指定的位数，但是保留符号位，右移空缺的符号位使用 `0` 填充

例如：将31有符号右移3位，等于3。

```ruby
0|000 0000 0000 0000 0000 0000 0001 1111
// >>3
0|000 0000 0000 0000 0000 0000 0000 0011
// 等于
(2^0 * 1) + (2^1 * 1) = 1 + 2 = 3
```

## 无符号位右移

无符号位右移，会将所有32位数都向右移动。对于正数来说右移和无符号位右移的结果是一致的。

例如：将-31无符号右移28位。

```ruby
1111 1111 1111 1111 1111 1111 1110 0001
// >>> 28
0000 0000 0000 0000 0000 0000 0000 1111
// 等于
(2^0 * 1) + (2^1 * 1) + (2^2 * 1) + (2^3 * 1) = 1 + 2 + 4 + 8 = 15
```

## 位操作符的奇妙用法

### `~~` 向下取整

按位非 `~`。将操作数取负值，并减1。对于浮点数，会直接舍弃小数的部分。比如 `~11.1 === -12` 。然后将结果，再次执行按位非操作，就会得到了去除小数位的原数字，`~-12 === 11`。因此我们可以使用 `~~` 代替 `Math.floor`。

```javascript
~~12.5        // 12
~~6.1         // 6
~~-8.1        // 8
```

> Math.floor和~~性能对比: 分别使用和Math.floor，对包含了10000000个浮点数的数组，进行向下取整。耗时386毫秒，Math.floor耗时411毫秒.

### `~` 判断索引是否存在

~-1等于0（-1取正值后减1）

平时使用indexOf等API时，当查询的字符串不存在时，`indexOf` 会返回-1。但是 `Boolean(-1)` 等于 `true`，所以我们在使用时通常需要添加一个判断'字符串`.indexOf('字') > -1`，看上去并不是那么的简洁。

`-1` 按位非等于`0`，而 `Boolean(0)` 是等于false的。所以我们可以把不等式简化成下面的样子。

```javascript
if ('string'.indexOf('s') > -1) {}
// 等价于
if (~'string'.indexOf('s')) {}
```

### `^` 不使用额外的空间交换两个变量的值

在了解这个技巧之前需要先了解两个准则：

- 两个相同的数进行按位异或等于0
- 任意一个数与0进行按位异或等于自身

```javascript
100 ^ 100       // 0
-99 ^ -99       // 0
100 ^ 0         // 100
0 ^ -2          // -2
```

在代码中交换两个变量的值，通常是通过第三个变量，或者使用ES6中的解构赋值

```javascript
// 使用第三个变量
var a = 1
var b = 2
var c = a
a = b
b = c

// 使用解构赋值
var x = 1
var y = 2
[x, y] = [y, x]

// 使用异或按位运算符
let a = 2
let b = 3

a = a ^ b
b = a ^ b   // b = a ^ b ^ b => a ^ (b ^ b) => a ^ 0 = a
a = a ^ b   // a = a ^ b ^ a ^ b ^ b => (a ^ a) ^ (b ^ b) ^ b => 0 ^ 0 ^ b => 0 ^ b = b
```

### `^` 切换位

使用异或按位运算符，可以用来切换二进制数中的某些位，这基于这样一个事实：

- 任意一个数与0进行按位异或等于自身
- 任意一个数与与1进行按位异或，总是被切换（参考下面的例子）

```javascript
let a = 1
a = 1 ^ 1     // 0
a = a ^ 1     // 1 (又变回了1)
```

例如：`let a = 0b101011`, 我们想将中间的四位进行切换(0->1, 1->0)变为 `0b110101`。我们创建一个掩码，首尾为0，中间四位为1, 使用掩码进行按位异或的操作。

```javascript
let mask = 0b011110   // 掩码
let a = 0b101011
a ^ mask              // 0b110101
```

### `&` 关闭高位

使用按位与&, 可以用来关闭二进制数中的某些位，这基于这样一个事实：

- `N & 0 === 0` 任意一个数与0，按位与，等于0
- `N & N === N` 任意一个数与自身，按位与，等于自身
- `N & -N === 0` 任意一个数与自身负值，按位与，等于0
- `N & -1 === N` 任意一个数与-1，按位与，等于自身

比如我们有一个8位的二进制数，我们需要关闭后4位(设置为0)，我们首先创建一个8位的位掩码，位掩码的后四位设置为0，前四位设置为1。接下来使用位掩码与操作数进行按位与操作

```javascript
const mask = 0b00001111
mask & 0b10101010         // 结果00001010，成功将后四位设置为0
```

### `&` 检查设置位

可以使用按位与，检查二进制数中某一位是否设置了。

例如：我们需要检查第五位是否有数字。

```javascript
const mask = 0b10000
0b100010 & mask === mask      // false
0b110010 & mask === mask      // true
```

### `&` 判断奇数或偶数

奇数与偶数的二进制表示的特性：

- 偶数的二进制的第一位始终是0
- 奇数的二进制的第一位始终是1

```javascript
0       // 0b0
1       // 0b1
2       // 0b10
3       // 0b11
4       // 0b100
5       // 0b101
6       // 0b110
```

所以我们可以使用0001作为掩码，使用0关闭高位，只保留第一位。当 `number & 1 === 1`, number为 `奇数`。`number & 1 === 0`, number为 `偶数`。

- 偶数与0b1，按位与，结果必定等于0
- 奇数与0b1，按位与，结果必定等于1

```javascript
(3 & 1) === 1       // 奇数
(4 & 1) === 0       // 偶数
```

### `<<` 、`>>` 移位实现乘除法

左移1位，等于乘以2，左移2位，等于乘以4。但是对于乘以7或者乘以9该怎么办呢？乘以7，可以分解为左移3位并减去一位，`a * 7 === (a << 3) - a`。乘以9，可以分解为左移3位并加上一位`a * 9 === (a << 3) + a`

- 左移1位，等价于，乘以2的1次方。
- 左移2位，等价于，乘以2的2次方。
- 左移3位，等价于，乘以2的3次方。

```javascript
a * 2 === a << 1
a * 3 === (a << 1) + a
a * 4 === a << 2
```

- 右移1位，等价于，除以2的1次方。
- 右移2位，等价于，除以2的2次方。
- 右移3位，等价于，除以2的3次方。

```javascript
a / 2 === a >> 1
a / 4 === a >> 2
a / 8 === a >> 3
```

### 利用位操作符，解答leetcode

- 利用右移，「leetcode」29.两数相除
- 利用异或，「leetcode」136.只出现一次的数字
- 利用异或，「leetcode」268.缺失数字
- 利用按位与，「leetcode」191.位1的个数
- 利用右移和按位与, 「leetcode」78.子集
- 利用按为与, 「leetcode」231.2的幂
- 利用异或和按位与，「leetcode」371.两整数之和
